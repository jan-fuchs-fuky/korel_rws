#!/usr/bin/env python2.5
# -*- coding: utf-8 -*-

""" Korel RESTful Web Services """

#
# Author: Jan Fuchs <fuky@sunstel.asu.cas.cz>
# $Date$
# $Rev$
#

#
#    In CherryPy 3.1, cherrypy.engine can do all of the above via the
#    Daemonizer plugin: 
#
#        from cherrypy.restsrv.plugins import Daemonizer, PIDFile 
#        Daemonizer(cherrypy.engine).subscribe()
#
#    ...and manage pid files via: 
#
#        PIDFile(cherrypy.engine, filename).subscribe()
#

import os
import sys
import re
import uuid
import tempfile
import subprocess
import cherrypy
import urllib
import random
import bcrypt
import time
import logging
import Image
import ImageDraw
import ImageFont
import ConfigParser
from optparse import OptionParser
from lxml import etree
from cherrypy import _cperror
from cherrypy.lib import httpauth
from cherrypy.lib.static import serve_file
from StringIO import StringIO

script_path = os.path.dirname(os.path.realpath(os.path.abspath(sys.argv[0])))
sys.path.append(os.path.abspath("%s/lib" % script_path))
os.chdir(script_path)

import jobs
import template
import share

from mail import send_mail

font = ImageFont.load("./share/fonts/ter-u24n_unicode.pil")
parser = etree.XMLParser(remove_blank_text=True)

environ = {}
patterns = {}
patterns.update({"login": re.compile("^[a-zA-Z][a-zA-Z._]*$")})

USERS_PATH = "./etc/users"
TMP_PATH = "./var/tmp"
VAR_RUN_PATH = "./var/run"
VAR_LOG_PATH = "./var/log"
KOREL_RWS_PID = "./var/run/korel_rws.pid"
EXPIRED_MATHPROBLEM = 600
MATHPROBLEMS_ON_ONEIP = 100

def rm_expired_mathproblem():
    ip_dict = {}
    for file in os.listdir(TMP_PATH):
        file_path = "%s/%s" % (TMP_PATH, file)
        if ((os.path.isfile(file_path)) and (file[:12] == "mathproblem_")):
            ip = file[12:file[12:].find("_")+12]

            if (not ip_dict.has_key(ip)):
                ip_dict.update({ip: []})

            ip_dict[ip].append(file_path)

            file_mtime = os.stat(file_path).st_mtime
            if ((time.time() - file_mtime) >= EXPIRED_MATHPROBLEM):
                os.remove(file_path)

    for key in ip_dict.keys():
        if (len(ip_dict[key]) > MATHPROBLEMS_ON_ONEIP):
            for file_path in ip_dict[key]:
                subprocess.call(["rm", file_path])

def make_mathproblem():
    rm_expired_mathproblem()

    png_path = tempfile.mktemp(".png", "mathproblem_%s_" % cherrypy.request.remote.ip, dir=TMP_PATH)

    img = Image.new("RGB", (130, 45), "White")
    
    x = random.randint(0, 9)
    operation_chr = ["+", "-", "*"][random.randint(0, 2)]
    y = random.randint(0, 9)
    result = eval("%i %s %i" % (x, operation_chr, y))

    drawing = ImageDraw.ImageDraw(img, "RGB")
    drawing.text((0, 0), "(%i %s %i) = " % (x, operation_chr, y), fill=0, font=font)
    
    img.save(png_path)

    result_fo = open("%s.solution" % png_path, "w")
    result_fo.write("%i\n" % result)
    result_fo.close()

    return os.path.basename(png_path)

def make_confirmation(login):
    confirmation = uuid.uuid4()

    fo = open("%s/confirmation_%s" % (TMP_PATH, confirmation), "w")
    fo.write("%s\n" % login)
    fo.close()

    return confirmation

def action_confirmation(confirmation):
    confirmation_file = "%s/confirmation_%s" % (TMP_PATH, confirmation)

    if (os.path.isfile(confirmation_file)):
        fo = open(confirmation_file, "r")
        login = fo.read().strip()
        fo.close()

        user_filename = "%s/%s.xml" % (USERS_PATH, login)

        tree = etree.parse(user_filename, parser)
        user_elt = tree.xpath("/user")[0]
        user_elt.attrib["allow"] = "true"

        fo = open(user_filename, "w")
        fo.write(etree.tostring(tree.getroot(), encoding="UTF-8", xml_declaration=True, pretty_print=True))
        fo.close()

        os.remove(confirmation_file)
        
        result  = "<body><![CDATA["
        result += "<h2>Register user</h2>"
        result += "Welcome <b>%s</b>, registration is success." % login
        result += "]]></body>"

        return template.xml2result(result)
    else:
        raise cherrypy.HTTPError(400, "Bad Request")

def korel_lock(lock, timeout=1000):
    i = 0
    while (1):
        try:
            fd = os.open(lock, os.O_RDWR | os.O_CREAT | os.O_EXCL, 0644)
            os.write(fd, "%s\n" % time.time())
            os.close(fd)
            break
        except Exception, e:
            i += 1

            if (i <= timeout):
                # waiting 50ms
                time.sleep(0.05)
                continue
            else:
                # TODO: zapsat do logu a poslat mail
                raise Exception("Create lock file failure")

def korel_unlock(lock):
    os.remove(lock)

def register_user(params):
    user_filename = "%s/%s.xml" % (USERS_PATH, params["login"])
    lock = "%s/user_%s.lock" % (VAR_RUN_PATH, params["login"])
    locked = False

    try:
        try:
            # LOCK
            korel_lock(lock, 0)
            locked = True
            user_fd = os.open(user_filename, os.O_RDWR | os.O_CREAT | os.O_EXCL, 0644)
        except:
            return "Please enter other login. Login '%s' exists." % params["login"]

        salt = bcrypt.gensalt()
        hashed_password = bcrypt.hashpw(params["password"], salt)

        user_xml  = "<?xml version='1.0' encoding='UTF-8'?>\n"
        user_xml += "<user allow='false'>\n"
        user_xml += "    <first_name>%s</first_name>\n" % params["first_name"]
        user_xml += "    <surname>%s</surname>\n" % params["surname"]
        user_xml += "    <organization>%s</organization>\n" % params["organization"]
        user_xml += "    <email>%s</email>\n" % params["email"]
        user_xml += "    <hashed_password>%s</hashed_password>\n" % hashed_password
        user_xml += "</user>\n"

        os.write(user_fd, user_xml)
        os.close(user_fd)
    finally:
        if (locked):
            korel_unlock(lock)
            # UNLOCK

    return ""

class RootServer:
    @cherrypy.expose
    def index(self):
        return template.xml2result("./xml/index.xml")

    @cherrypy.expose
    def logout(self):
        cookie = cherrypy.response.cookie
        cookie["KorelLogout"] = "true"

        cherrypy.response.headers["www-authenticate"] = httpauth.basicAuth("Korel RESTful Web Services") 
        raise cherrypy.HTTPError(401, "You are not authorized to access that resource") 

    @cherrypy.expose
    def login(self):
        cookie = cherrypy.response.cookie
        cookie["KorelLogout"] = "false"

        raise cherrypy.HTTPRedirect(["/jobs"], 303)

    @cherrypy.expose
    def user(self, *vpath, **params):
        method = cherrypy.request.method

        what = vpath[0]

        if ((method == "POST") and (what == "register")):
            # defence against mathproblem_png == "../../any_file" atack
            mathproblem_png = os.path.basename(params["mathproblem_png"])
            if (len(mathproblem_png) != len(params["mathproblem_png"])):
                raise cherrypy.HTTPError(400, "Bad Request")

            # defence against mathproblem_png != "mathproblem_*" atack
            if (params["mathproblem_png"][:12] != "mathproblem_"):
                raise cherrypy.HTTPError(400, "Bad Request")

            mathproblem_png = "%s/%s" % (TMP_PATH, params["mathproblem_png"])
            mathproblem_solution = "%s/%s.solution" % (TMP_PATH, params["mathproblem_png"])

            errmsg = ""
            if (os.path.isfile(mathproblem_solution)):
                solution_fo = open(mathproblem_solution, "r")
                solution = solution_fo.read().strip()
                solution_fo.close()

                subprocess.call(["rm", mathproblem_png])
                subprocess.call(["rm", mathproblem_solution])

                if (params["mathproblem_solution"] != solution):
                    errmsg = "Bad solution math problem."
                elif (params["password"] != params["retype_password"]):
                    errmsg = "Bad re-type password."
                elif ("" in params.values()):
                    errmsg = "All values is required."
                elif (len(params["password"]) < 6):
                    errmsg = "Password must have min. 6 characters."
                elif (len(params["login"]) < 3):
                    errmsg = "Login must have min. 3 characters."
                elif (not patterns["login"].findall(params["login"])):
                    errmsg = "Login '%s' is not valid." % params["login"]
            else:
                errmsg = "Math problem expired. Solve new math problem."

            if (not errmsg):
                confirmation = make_confirmation(params["login"])

                body  = "Please confirm you registration on Korel RESTful Web Services:\n\n"
                body += "https://stelweb.asu.cas.cz/vo-korel/user/confirm/%s\n\n" % confirmation
                body += "First name: %s\n" % params["first_name"]
                body += "Surname: %s\n" % params["surname"]
                body += "Organization: %s\n" % params["organization"]
                body += "Login: %s\n" % params["login"]
                body += "Password: %s\n" % params["password"]
                body += "E-mail: %s\n" % params["email"]

                send_mail(params["email"], "Korel RESTful Web Service: Register user", body, options)
                errmsg = register_user(params)

                result  = "<body><![CDATA["
                result += "<h2>Register user</h2>"
                result += "Please confirm registration on your e-mail address."
                result += "]]></body>"

            if (errmsg != ""):
                for key in params.keys():
                    if (key in ["password", "retype_password", "mathproblem_solution"]):
                        params.pop(key)

                params.update({"errmsg": errmsg})
                raise cherrypy.HTTPRedirect(["/user/register?%s" % urllib.urlencode(params)], 303)

            return template.xml2result(result)
        elif ((method == "GET") and (what == "register")):
            mathproblem_png = make_mathproblem()

            result  = "<register_user>"
            result += "<mathproblem_png>%s</mathproblem_png>" % mathproblem_png

            if (params != {}):
                for key in params:
                    result += "<%s>%s</%s>" % (key, params[key], key)

            result += "</register_user>"

            return template.xml2result(result)
        elif ((method == "GET") and (what == "confirm")):
            return action_confirmation(vpath[1])
        else:
            raise cherrypy.HTTPError(400, "Bad Request")

    @cherrypy.expose
    def mathproblem(self, file):
        if (file[-4:] != ".png"):
            raise cherrypy.HTTPError(400, "Bad Request")

        file_path = os.path.abspath("%s/%s" % (TMP_PATH, file))
        return serve_file(file_path)

    @cherrypy.expose
    def css(self, file):
        file_path = os.path.abspath("./css/%s" % file)
        return serve_file(file_path)

    @cherrypy.expose
    def jobs(self, *vpath, **params):
        vpath_des = ["id", "what", "file"]

        for i in range(len(vpath)):
            params.update({vpath_des[i]: vpath[i]})

        if (self.check_auth()):
            method = cherrypy.request.method
            if (method not in ["GET", "POST", "DELETE", "PUT"]):
                raise cherrypy.HTTPError(400, "Bad Request")

            http_method = getattr(self, method)
            return (http_method)(params)
        else:
            cherrypy.response.headers["www-authenticate"] = httpauth.basicAuth("Korel RESTful Web Services") 
            raise cherrypy.HTTPError(401, "You are not authorized to access that resource") 

    def GET(self, params):
        if (not params.has_key("id")):
            return jobs.list(self.username, self.user_settings["max_disk_space"])
        elif (params.has_key("what")):
            if (params["what"] == "phase"):
                return jobs.phase(self.username, params["id"])
            elif (params["what"] == "again"):
                return jobs.again(self.username, self.email, params["id"])
            elif (params["what"] == "results"):
                if (params.has_key("file")):
                    return jobs.download(self.username, params["id"], params["file"])
                else:
                    return jobs.results(self.username, params["id"])
            elif (params["what"] == "destruction"):
                return jobs.destruction(self.username, params["id"])
            elif (params["what"] == "lifetime"):
                raise cherrypy.HTTPError(400, "Bad Request")
            elif (params["what"] == "quote"):
                raise cherrypy.HTTPError(400, "Bad Request")
            else:
                raise cherrypy.HTTPError(400, "Bad Request")
        else:
            return jobs.detail(self.username, params["id"])

    def POST(self, params):
        if (not params.has_key("id")):
            if (not params.has_key("korel_dat")) or (not params.has_key("korel_archive")):
                result  = "<start_new_job><email>%s</email></start_new_job>" % self.email
                return template.xml2result(result, self.username)
            return jobs.start(self.username, params, self.user_settings["max_disk_space"])
        elif (params.has_key("what")):
            if (params["what"] == "againstart"):
                return jobs.againstart(self.username, params, environ, self.user_settings["max_disk_space"])
            elif (params["what"] == "phase") and (params.has_key("PHASE")):
                if (params["PHASE"] == "ABORT"):
                    return jobs.abort(self.username, params["id"])
                elif (params["PHASE"] == "RUN"):
                    return jobs.run(self.username, params["id"], environ)
        elif (params.has_key("ACTION")):
            if (params["ACTION"] == "DELETE"):
                return jobs.delete(self.username, params["id"])
        else:
            raise cherrypy.HTTPError(400, "Bad Request")

    def DELETE(self, params):
        if (params.has_key("id")):
            return jobs.delete(self.username, params["id"])
        else:
            raise cherrypy.HTTPError(400, "Bad Request")

    def PUT(self, params):
        raise cherrypy.HTTPError(400, "Bad Request")

    def check_auth(self): 
        try: 
            auth = httpauth.parseAuthorization(cherrypy.request.headers['authorization']) 
        except KeyError: 
            return False 

        self.username = auth['username'] 
        self.password = auth['password'] 
        self.email = ""
        user_xml = "%s/%s.xml" % (USERS_PATH, self.username)

        if (os.path.isfile(user_xml)):
            self.user_settings = share.get_user_settings("%s/%s.xml" % (share.KOREL_USERS_PATH, self.username))

            if (self.user_settings["attrib"].has_key("allow")) and (self.user_settings["attrib"]["allow"] != "true"):
                return False

            self.email = self.user_settings["email"]
            hashed_password = self.user_settings["hashed_password"]

            salt = hashed_password[:hashed_password.rfind("$")+23]

            if (bcrypt.hashpw(self.password, salt) != hashed_password):
                return False

            if (not self.user_settings.has_key("max_disk_space")):
                self.user_settings.update({"max_disk_space": share.settings["max_disk_space"]})
            self.user_settings["max_disk_space"] *= (1024 * 1024)

            try:
                home = "%s/%s" % (jobs.JOBS_PATH, self.username)
                if (not os.path.isdir(home)):
                    os.mkdir(home)
                return True 
            except:
                return False
        else: 
            self.username = ""
            self.password = ""
            return False 

def handle_error():
    cherrypy.response.status = 500

    result  = "<body><![CDATA["
    result += "<h2>Error</h2>"
    result += "Sorry, an error occurred."
    result += "]]></body>"

    cherrypy.response.body = [ template.xml2result(result) ]
    send_mail("fuky@fuky.org", "Error in Korel RESTful Web Service", _cperror.format_exc(), options)

#
#   Note that the internal CherryPy engine by default attempts to register signal
#   handlers for SIGTERM and SIGHUP.
#
def main():
    share.create_pid(KOREL_RWS_PID)

    cherrypy.log.screen = False
    cherrypy.log.access_file = os.path.abspath("%s/access.log" % VAR_LOG_PATH)
    cherrypy.log.error_file = os.path.abspath("%s/error.log" % VAR_LOG_PATH)

    #cfg = ConfigParser.RawConfigParser()
    #cfg.add_section("smtp")
    #cfg.set("smtp", "addresss", options.smtp_address)
    #cfg.set("smtp", "port", options.smtp_port)
    #cfg.set("smtp", "user", options.smtp_user)
    #cfg.set("smtp", "password", options.smtp_password)
    #cfg.set("smtp", "ssl", options.smtp_ssl)

    #fo_cfg = open("./etc/korel_rws.cfg", "w")
    #cfg.write(fo_cfg)
    #fo_cfg.close()

    config = {
        'global': {
            'server.socket_host': options.address,
            'server.socket_port': options.port,
            'server.ssl_certificate': 'cert.pem',
            'server.ssl_private_key': 'key.pem',
            'request.error_response': handle_error,
            'error_page.404': "error/404.html",
            'error_page.401': "error/401.html"
        }
    } 
 
    cherrypy.quickstart(RootServer(), '/', config=config)

if __name__ == '__main__':
    option_parser = OptionParser()

    option_parser.add_option("-p", "--port", dest="port", type="int", default=None)
    option_parser.add_option("-a", "--address", dest="address", default=None)
    option_parser.add_option("-d", "--daemonize", dest="daemonize", default=None, action="store_true")
    option_parser.add_option("-c", "--conf", dest="conf", default="korel_rws.cfg")
    option_parser.add_option("--smtp-ssl", dest="smtp_ssl", default=None, action="store_true")
    option_parser.add_option("--smtp-user", dest="smtp_user", default=None)
    option_parser.add_option("--smtp-password", dest="smtp_password", default=None)
    option_parser.add_option("--smtp-addresss", dest="smtp_address", default=None)
    option_parser.add_option("--smtp-port", dest="smtp_port", type="int", default=None)
    option_parser.add_option("--service-url", dest="service_url", default=None)

    (options, args) = option_parser.parse_args()
    #print "options: %s, args: %s" % (options, args)

    cfg = ConfigParser.RawConfigParser()
    cfg.read("%s/etc/%s" % (os.path.dirname(__file__), options.conf))

    if (options.address is None):
        options.address = cfg.get("server", "address")
    if (options.port is None):
        options.port = cfg.getint("server", "port")
    if (options.daemonize is None):
        options.daemonize = cfg.getboolean("server", "daemonize")
    if (options.smtp_address is None):
        options.smtp_address = cfg.get("smtp", "address")
    if (options.smtp_port is None):
        options.smtp_port = cfg.getint("smtp", "port")
    if (options.smtp_user is None):
        options.smtp_user = cfg.get("smtp", "user")
    if (options.smtp_password is None):
        options.smtp_password = cfg.get("smtp", "password")
    if (options.smtp_ssl is None):
        options.smtp_ssl = cfg.getboolean("smtp", "ssl")
    if (options.service_url is None):
        options.service_url = cfg.get("server", "service-url")

    share.settings.update({"max_process": cfg.getint("korel", "max_process")})
    share.settings.update({"max_memory": cfg.getint("korel", "max_memory")})
    share.settings.update({"max_disk_space": cfg.getint("korel", "max_disk_space")})
    share.settings.update({"max_upload_file": cfg.getint("korel", "max_upload_file") * 1024 * 1024})
    share.settings.update({"max_runtime": cfg.getint("korel", "max_runtime")})

    os.environ.update({"KOREL_SERVICE_URL": options.service_url})

    environ.update({"KOREL_SMTP_ADDREESS": options.smtp_address})
    environ.update({"KOREL_SMTP_PORT": str(options.smtp_port)})
    environ.update({"KOREL_SMTP_USER": options.smtp_user})
    environ.update({"KOREL_SMTP_PASSWORD": options.smtp_password})
    environ.update({"KOREL_SMTP_SSL": str(options.smtp_ssl)})
    environ.update({"KOREL_MAX_PROCESS": cfg.get("korel", "max_process")})

    #print options

    if (options.daemonize):
        share.daemonize()

    try:
        main()
    finally:
        if (os.path.isfile(KOREL_RWS_PID)):
            os.remove(KOREL_RWS_PID)
